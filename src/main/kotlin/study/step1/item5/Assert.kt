package study.step1.item5

/*
자체 구현이 상태를 올바르게 처리한다고 믿지 못할 때,
자체 구현을 테스트 하기 위해 검사하는 경우는 assert를 사용한다.

우리의 기대가 현실과 일치하는지 확인하는 단위 테스트를 작성하는 것.

 */

fun main() {
}

// class StackTest {
//    @Test
//    fun `Stack pops correct number of elements`() {
//        val stack = Stack(20) { it }
//        val ret = stack.pop(10)
//        assertEquals(10, ret.size)
//    }
// }

/*
단위 테스트는 구현 정확성을 확인하는 가장 기본적인 방법이지만,
여기서 주목할 점은 팝된 목록 크기가 원하는 목록 크기와 일치한다는 사실은 이 함수에 다소 보편적으로 적용된다는 점
모든 pop 함수 호출에 검사를 추가하기 위해서 함수 내부에 추가하는게 유용할 수도?
 */

//fun pop(num: Int = 1): List<T> {
//    assert(ret.size == num)
//    return ret
//}

/*
테스트를 실행할때만 기본적으로 활성화된다.
오류가 발생할 가능성이 높고 중대한 결과를 초래할 수 있는 심각한 오류인 경우 대신 check를 사용해라.
- assertion은 코드 자체 점검을 가능하게 하고 보다 효과적인 테스트로 이어진다.
- 구체적인 사례가 아닌 모든 실제 사용 사례에 대해 기대치를 확인한다.
- 이를 통해 정확한 실행 시점에 무언가를 확인할 수 있다.
- 실제 문제에 더 가깝게 조기에 코드를 실패하게 만든다.

표준 어플리케이션 실행에서 assert는 예외를 발생시키지 않기떄문에 단위 테스트를 작성해라.
 */
